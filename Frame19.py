from gmpy2 import *
from Crypto.Util.number import *

def Pollard_p_1(N):
    a = 2
    while True:
        f = mpz(a)
        for n in range(1,1000000):
            f =powmod(f,n,N)
            if n in sieve_base:
                d =gcd(f-1,N)
                if 1 < d < N:
                    return d,N//d
                    break

N = 0x8614C70089AADE50E5A14DE1FB8FCF0880046E9494EEAD3BF600EBE451E335B4C9E21DE984912BCA15914711A9C359056A2AD0543035E971A2FAA387EA53AAD48A7016735E2BB60716626CAD6CF4F9CC41A59CF31EF07473A1DE08A018CAB7C6B95BF7AC9F501BD42FCC4C7CD834B6A7723B6ABCC9A98146A750A9222CCE2CC7
c= 0x4B6A6A6CE0CD9D8E0DF4FBD2A23AF3FB45FA587406A3E052231519C4B6B0B606D64DC531A29C0A7510928D4487E7BC3D45CDBADB595AE7D53FBDEE70371DEBCB9A938B94DC0F266326A9DF6191E04F82A9CDC067D366926B58A9092F55DB22F8D4BCD9777A99F14ED95083D091DA69F80F448EFF48A21F998BBDC97DAEA135C1
p,q = Pollard_p_1(N)
phi = (q-1)*(p-1)
e = 0x10001
d = invert(e,phi)

m = long_to_bytes(pow(c,d,N))
print(m)

# m = instein