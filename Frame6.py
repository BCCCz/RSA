#Pollard p-1
from gmpy2 import *
from Crypto.Util.number import *

def Pollard_p_1(N):
    a = 2
    while True:
        f = mpz(a)
        for n in range(1,1000000):
            f =powmod(f,n,N)
            if n in sieve_base:
                d =gcd(f-1,N)
                if 1 < d < N:
                    return d,N//d
                    break

N = 0xD11B49BF43234D6595219AB7C21730DE0A13A7A01E63831A4D4F8DC5A7E68FCA0E9768EF0DABCAD036E08E17E4B27C1151DF364556D8F93D19565D9F40F095A49C6185F2630671EB5EC1EAA514BEC32D93A0F0459B52F1E34D4B9113413403F66619262EF1D3CBB025648C997CD1438DE21CFE4BEA0C6E00C72FFDE587929CB3
c= 0x4333AF6B43F36028D8D9650EC3EED3238541EE5C15E626C58C9EC33674A6D08D5B1F2580A1A0B07E9D853536CD994E197889D122701A62BB2A9E79559F3D5281014535F6C54F83CA8D9700EEB67D99AF318D20A5150AD46D622A6A12DE0A758EE7DF75F5D10F2FE2585F2348537787063321FFDAC91BB3C3D1D88CBD04A824ED
p,q = Pollard_p_1(N)
phi = (q-1)*(p-1)
e = 0x10001
d = invert(e,phi)

m = long_to_bytes(pow(c,d,N))
print(m)

#m=